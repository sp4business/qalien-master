-- This table will store all creatives waiting for AI processing.
CREATE TABLE public.ai_job_queue (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  asset_id UUID NOT NULL REFERENCES public.campaign_assets(id) ON DELETE CASCADE,
  status TEXT NOT NULL DEFAULT 'pending', -- 'pending', 'processing', 'completed', 'failed'
  error_message TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ
);

-- Enable RLS for the new table.
ALTER TABLE public.ai_job_queue ENABLE ROW LEVEL SECURITY;

-- Add RLS policies as needed, likely allowing service_role keys full access.
-- Policy for service role to have full access
CREATE POLICY "Service role has full access to ai_job_queue"
  ON public.ai_job_queue
  FOR ALL
  TO service_role
  USING (true)
  WITH CHECK (true);

-- Policy for authenticated users to view their own organization's jobs
CREATE POLICY "Users can view their organization's jobs"
  ON public.ai_job_queue
  FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.campaign_assets ca
      JOIN public.campaigns c ON ca.campaign_id = c.id
      JOIN public.brands b ON c.brand_id = b.id
      WHERE ca.id = ai_job_queue.asset_id
      AND b.clerk_org_id = public.clerk_org_id()
    )
  );

-- Create an index on status for efficient queue processing
CREATE INDEX idx_ai_job_queue_status ON public.ai_job_queue(status);

-- Create an index on created_at for ordering
CREATE INDEX idx_ai_job_queue_created_at ON public.ai_job_queue(created_at);

-- Add a trigger to update the updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_ai_job_queue_updated_at
  BEFORE UPDATE ON public.ai_job_queue
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();